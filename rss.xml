<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>yield this</title><link>https://yannpaul.github.io/blog/</link><description>Yet another blog...</description><atom:link href="https://yannpaul.github.io/blog/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Tue, 14 Jul 2015 00:39:34 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Topcoder</title><link>https://yannpaul.github.io/blog/posts/topcoder/</link><dc:creator>yannpaul</dc:creator><description>&lt;p&gt;I've only recently came across topcoder, a site where you can develop your
programming and design skills. They provide a UI to practice coding
and to compete in speed and code-quality challenges. It's a fine
interface, but I'd rather code in my own environment. I've developed a
scaffold that helps me work these
problems out on my on machine. A scaffold-ed project has a CMake
configuration file, a stubbed class to complete the
problem and an executable that drives a series GTest-based tests. The
tests match the examples provided in each problem description. Ideally
I would create a scraper that would pull all the values down from the site
automagically, but for now I populate some of the details
manually. &lt;cite&gt;Take a
look&amp;lt;https://github.com/yannpaul/cookiecutter-gtest&amp;gt;_&lt;/cite&gt; for yourself.&lt;/p&gt;</description><category>cookiecutter</category><category>gtest</category><category>topcoder</category><guid>https://yannpaul.github.io/blog/posts/topcoder/</guid><pubDate>Mon, 13 Jul 2015 20:50:07 GMT</pubDate></item><item><title>Names</title><link>https://yannpaul.github.io/blog/posts/names/</link><dc:creator>yannpaul</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;My wife is due to give birth any day now, and the responsibility of naming our
daughter is weighing on us. I've just started this blog; yet another attempt
to consolidate my adventures in computing. It's name may or may not be an obvious mashup of python's &lt;code&gt;yeild&lt;/code&gt; keword and the educational/informative &lt;code&gt;this&lt;/code&gt; module:&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;InÂ [1]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython2"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;this&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;When there's time, when they're ready, I &lt;em&gt;plan&lt;/em&gt; to yield some posts, pages, examples, etc. This is in part to better sell myself to potential employers. I'd also like to give back to the www, which always has something amazing to teach me. The nice thing about this blog and it's name is that they can change with little consiquence. On the other hand, my daughter's name is a little more permanent.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</description><category>personal</category><guid>https://yannpaul.github.io/blog/posts/names/</guid><pubDate>Fri, 10 Jul 2015 10:58:27 GMT</pubDate></item></channel></rss>